
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cache: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/GoCodeAlone/modular/modules/cache/memory.go (80.6%)</option>
				
				<option value="file1">github.com/GoCodeAlone/modular/modules/cache/module.go (73.8%)</option>
				
				<option value="file2">github.com/GoCodeAlone/modular/modules/cache/redis.go (97.1%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package cache

import (
        "context"
        "sync"
        "time"
)

// MemoryCache implements CacheEngine using in-memory storage
type MemoryCache struct {
        config     *CacheConfig
        items      map[string]cacheItem
        mutex      sync.RWMutex
        cleanupCtx context.Context
        cancelFunc context.CancelFunc
}

type cacheItem struct {
        value      interface{}
        expiration time.Time
}

// NewMemoryCache creates a new memory cache engine
func NewMemoryCache(config *CacheConfig) *MemoryCache <span class="cov8" title="1">{
        return &amp;MemoryCache{
                config: config,
                items:  make(map[string]cacheItem),
        }
}</span>

// Connect initializes the memory cache
func (c *MemoryCache) Connect(ctx context.Context) error <span class="cov8" title="1">{
        // Start cleanup goroutine
        c.cleanupCtx, c.cancelFunc = context.WithCancel(ctx)
        go c.startCleanupTimer(c.cleanupCtx)
        return nil
}</span>

// Close stops the memory cache cleanup routine
func (c *MemoryCache) Close(_ context.Context) error <span class="cov8" title="1">{
        if c.cancelFunc != nil </span><span class="cov8" title="1">{
                c.cancelFunc()
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Get retrieves an item from the cache
func (c *MemoryCache) Get(_ context.Context, key string) (interface{}, bool) <span class="cov8" title="1">{
        c.mutex.RLock()
        item, found := c.items[key]
        c.mutex.RUnlock()

        if !found </span><span class="cov8" title="1">{
                return nil, false
        }</span>

        // Check if the item has expired
        <span class="cov8" title="1">if !item.expiration.IsZero() &amp;&amp; time.Now().After(item.expiration) </span><span class="cov0" title="0">{
                c.mutex.Lock()
                delete(c.items, key)
                c.mutex.Unlock()
                return nil, false
        }</span>

        <span class="cov8" title="1">return item.value, true</span>
}

// Set stores an item in the cache
func (c *MemoryCache) Set(_ context.Context, key string, value interface{}, ttl time.Duration) error <span class="cov8" title="1">{
        c.mutex.Lock()
        defer c.mutex.Unlock()

        // If cache is full, reject new items
        if c.config.MaxItems &gt; 0 &amp;&amp; len(c.items) &gt;= c.config.MaxItems </span><span class="cov0" title="0">{
                _, exists := c.items[key]
                if !exists </span><span class="cov0" title="0">{
                        return ErrCacheFull
                }</span>
        }

        <span class="cov8" title="1">var exp time.Time
        if ttl &gt; 0 </span><span class="cov8" title="1">{
                exp = time.Now().Add(ttl)
        }</span>

        <span class="cov8" title="1">c.items[key] = cacheItem{
                value:      value,
                expiration: exp,
        }

        return nil</span>
}

// Delete removes an item from the cache
func (c *MemoryCache) Delete(_ context.Context, key string) error <span class="cov8" title="1">{
        c.mutex.Lock()
        defer c.mutex.Unlock()

        delete(c.items, key)
        return nil
}</span>

// Flush removes all items from the cache
func (c *MemoryCache) Flush(_ context.Context) error <span class="cov8" title="1">{
        c.mutex.Lock()
        defer c.mutex.Unlock()

        c.items = make(map[string]cacheItem)
        return nil
}</span>

// GetMulti retrieves multiple items from the cache
func (c *MemoryCache) GetMulti(ctx context.Context, keys []string) (map[string]interface{}, error) <span class="cov8" title="1">{
        result := make(map[string]interface{}, len(keys))
        for _, key := range keys </span><span class="cov8" title="1">{
                if value, found := c.Get(ctx, key); found </span><span class="cov8" title="1">{
                        result[key] = value
                }</span>
        }
        <span class="cov8" title="1">return result, nil</span>
}

// SetMulti stores multiple items in the cache
func (c *MemoryCache) SetMulti(ctx context.Context, items map[string]interface{}, ttl time.Duration) error <span class="cov8" title="1">{
        for key, value := range items </span><span class="cov8" title="1">{
                if err := c.Set(ctx, key, value, ttl); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// DeleteMulti removes multiple items from the cache
func (c *MemoryCache) DeleteMulti(ctx context.Context, keys []string) error <span class="cov0" title="0">{
        for _, key := range keys </span><span class="cov0" title="0">{
                if err := c.Delete(ctx, key); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// startCleanupTimer starts the cleanup timer for expired items
func (c *MemoryCache) startCleanupTimer(ctx context.Context) <span class="cov8" title="1">{
        ticker := time.NewTicker(time.Duration(c.config.CleanupInterval) * time.Second)
        defer ticker.Stop()

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ticker.C:<span class="cov8" title="1">
                        c.cleanupExpiredItems()</span>
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        return</span>
                }
        }
}

// cleanupExpiredItems removes expired items from the cache
func (c *MemoryCache) cleanupExpiredItems() <span class="cov8" title="1">{
        now := time.Now()
        c.mutex.Lock()
        defer c.mutex.Unlock()

        for key, item := range c.items </span><span class="cov8" title="1">{
                if !item.expiration.IsZero() &amp;&amp; now.After(item.expiration) </span><span class="cov8" title="1">{
                        delete(c.items, key)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package cache

import (
        "context"
        "time"

        "github.com/GoCodeAlone/modular"
)

// ModuleName is the name of this module
const ModuleName = "cache"

// ServiceName is the name of the service provided by this module
const ServiceName = "cache.provider"

// CacheModule represents the cache module
type CacheModule struct {
        name        string
        config      *CacheConfig
        logger      modular.Logger
        cacheEngine CacheEngine
}

// NewModule creates a new instance of the cache module
func NewModule() modular.Module <span class="cov8" title="1">{
        return &amp;CacheModule{
                name: ModuleName,
        }
}</span>

// Name returns the name of the module
func (m *CacheModule) Name() string <span class="cov8" title="1">{
        return m.name
}</span>

// RegisterConfig registers the module's configuration structure
func (m *CacheModule) RegisterConfig(app modular.Application) error <span class="cov8" title="1">{
        // Register the configuration with default values
        defaultConfig := &amp;CacheConfig{
                Engine:           "memory",
                DefaultTTL:       300,
                CleanupInterval:  60,
                MaxItems:         10000,
                RedisURL:         "",
                RedisPassword:    "",
                RedisDB:          0,
                ConnectionMaxAge: 60,
        }

        app.RegisterConfigSection(m.Name(), modular.NewStdConfigProvider(defaultConfig))
        return nil
}</span>

// Init initializes the module
func (m *CacheModule) Init(app modular.Application) error <span class="cov8" title="1">{
        // Retrieve the registered config section for access
        cfg, err := app.GetConfigSection(m.name)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">m.config = cfg.GetConfig().(*CacheConfig)
        m.logger = app.Logger()

        // Initialize the appropriate cache engine based on configuration
        switch m.config.Engine </span>{
        case "memory":<span class="cov8" title="1">
                m.cacheEngine = NewMemoryCache(m.config)
                m.logger.Info("Initialized memory cache engine", "maxItems", m.config.MaxItems)</span>
        case "redis":<span class="cov8" title="1">
                m.cacheEngine = NewRedisCache(m.config)
                m.logger.Info("Initialized Redis cache engine", "url", m.config.RedisURL)</span>
        default:<span class="cov0" title="0">
                m.cacheEngine = NewMemoryCache(m.config)
                m.logger.Warn("Unknown cache engine specified, using memory cache", "specified", m.config.Engine)</span>
        }

        <span class="cov8" title="1">m.logger.Info("Cache module initialized")
        return nil</span>
}

// Start performs startup logic for the module
func (m *CacheModule) Start(ctx context.Context) error <span class="cov8" title="1">{
        m.logger.Info("Starting cache module")
        err := m.cacheEngine.Connect(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Stop performs shutdown logic for the module
func (m *CacheModule) Stop(ctx context.Context) error <span class="cov8" title="1">{
        m.logger.Info("Stopping cache module")
        return m.cacheEngine.Close(ctx)
}</span>

// Dependencies returns the names of modules this module depends on
func (m *CacheModule) Dependencies() []string <span class="cov0" title="0">{
        return nil
}</span>

// ProvidesServices declares services provided by this module
func (m *CacheModule) ProvidesServices() []modular.ServiceProvider <span class="cov8" title="1">{
        return []modular.ServiceProvider{
                {
                        Name:        ServiceName,
                        Description: "Cache service for storing and retrieving data",
                        Instance:    m,
                },
        }
}</span>

// RequiresServices declares services required by this module
func (m *CacheModule) RequiresServices() []modular.ServiceDependency <span class="cov0" title="0">{
        return nil
}</span>

// Constructor provides a dependency injection constructor for the module
func (m *CacheModule) Constructor() modular.ModuleConstructor <span class="cov0" title="0">{
        return func(app modular.Application, services map[string]any) (modular.Module, error) </span><span class="cov0" title="0">{
                return m, nil
        }</span>
}

// Get retrieves a cached item by key
func (m *CacheModule) Get(ctx context.Context, key string) (interface{}, bool) <span class="cov8" title="1">{
        return m.cacheEngine.Get(ctx, key)
}</span>

// Set stores an item in the cache with an optional TTL
func (m *CacheModule) Set(ctx context.Context, key string, value interface{}, ttl time.Duration) error <span class="cov8" title="1">{
        if ttl == 0 </span><span class="cov0" title="0">{
                ttl = time.Duration(m.config.DefaultTTL) * time.Second
        }</span>
        <span class="cov8" title="1">return m.cacheEngine.Set(ctx, key, value, ttl)</span>
}

// Delete removes an item from the cache
func (m *CacheModule) Delete(ctx context.Context, key string) error <span class="cov8" title="1">{
        return m.cacheEngine.Delete(ctx, key)
}</span>

// Flush removes all items from the cache
func (m *CacheModule) Flush(ctx context.Context) error <span class="cov8" title="1">{
        return m.cacheEngine.Flush(ctx)
}</span>

// GetMulti retrieves multiple items from the cache
func (m *CacheModule) GetMulti(ctx context.Context, keys []string) (map[string]interface{}, error) <span class="cov8" title="1">{
        return m.cacheEngine.GetMulti(ctx, keys)
}</span>

// SetMulti stores multiple items in the cache
func (m *CacheModule) SetMulti(ctx context.Context, items map[string]interface{}, ttl time.Duration) error <span class="cov8" title="1">{
        if ttl == 0 </span><span class="cov0" title="0">{
                ttl = time.Duration(m.config.DefaultTTL) * time.Second
        }</span>
        <span class="cov8" title="1">return m.cacheEngine.SetMulti(ctx, items, ttl)</span>
}

// DeleteMulti removes multiple items from the cache
func (m *CacheModule) DeleteMulti(ctx context.Context, keys []string) error <span class="cov0" title="0">{
        return m.cacheEngine.DeleteMulti(ctx, keys)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package cache

import (
        "context"
        "encoding/json"
        "time"

        "github.com/redis/go-redis/v9"
)

// RedisCache implements CacheEngine using Redis
type RedisCache struct {
        config *CacheConfig
        client *redis.Client
}

// NewRedisCache creates a new Redis cache engine
func NewRedisCache(config *CacheConfig) *RedisCache <span class="cov8" title="1">{
        return &amp;RedisCache{
                config: config,
        }
}</span>

// Connect establishes connection to Redis
func (c *RedisCache) Connect(ctx context.Context) error <span class="cov8" title="1">{
        opts, err := redis.ParseURL(c.config.RedisURL)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        
        <span class="cov8" title="1">if c.config.RedisPassword != "" </span><span class="cov8" title="1">{
                opts.Password = c.config.RedisPassword
        }</span>
        
        <span class="cov8" title="1">opts.DB = c.config.RedisDB
        opts.ConnMaxLifetime = time.Duration(c.config.ConnectionMaxAge) * time.Second
        
        c.client = redis.NewClient(opts)
        
        // Test the connection
        return c.client.Ping(ctx).Err()</span>
}

// Close closes the connection to Redis
func (c *RedisCache) Close(ctx context.Context) error <span class="cov8" title="1">{
        if c.client != nil </span><span class="cov8" title="1">{
                return c.client.Close()
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Get retrieves an item from the Redis cache
func (c *RedisCache) Get(ctx context.Context, key string) (interface{}, bool) <span class="cov8" title="1">{
        if c.client == nil </span><span class="cov8" title="1">{
                return nil, false
        }</span>
        
        <span class="cov8" title="1">val, err := c.client.Get(ctx, key).Result()
        if err != nil </span><span class="cov8" title="1">{
                if err == redis.Nil </span><span class="cov8" title="1">{
                        return nil, false
                }</span>
                <span class="cov0" title="0">return nil, false</span>
        }
        
        <span class="cov8" title="1">var result interface{}
        if err := json.Unmarshal([]byte(val), &amp;result); err != nil </span><span class="cov8" title="1">{
                return nil, false
        }</span>
        
        <span class="cov8" title="1">return result, true</span>
}

// Set stores an item in the Redis cache with a TTL
func (c *RedisCache) Set(ctx context.Context, key string, value interface{}, ttl time.Duration) error <span class="cov8" title="1">{
        if c.client == nil </span><span class="cov8" title="1">{
                return ErrNotConnected
        }</span>
        
        <span class="cov8" title="1">data, err := json.Marshal(value)
        if err != nil </span><span class="cov8" title="1">{
                return ErrInvalidValue
        }</span>
        
        <span class="cov8" title="1">return c.client.Set(ctx, key, data, ttl).Err()</span>
}

// Delete removes an item from the Redis cache
func (c *RedisCache) Delete(ctx context.Context, key string) error <span class="cov8" title="1">{
        if c.client == nil </span><span class="cov8" title="1">{
                return ErrNotConnected
        }</span>
        
        <span class="cov8" title="1">return c.client.Del(ctx, key).Err()</span>
}

// Flush removes all items from the Redis cache
func (c *RedisCache) Flush(ctx context.Context) error <span class="cov8" title="1">{
        if c.client == nil </span><span class="cov8" title="1">{
                return ErrNotConnected
        }</span>
        
        <span class="cov8" title="1">return c.client.FlushDB(ctx).Err()</span>
}

// GetMulti retrieves multiple items from the Redis cache
func (c *RedisCache) GetMulti(ctx context.Context, keys []string) (map[string]interface{}, error) <span class="cov8" title="1">{
        if len(keys) == 0 </span><span class="cov8" title="1">{
                return make(map[string]interface{}), nil
        }</span>
        
        <span class="cov8" title="1">if c.client == nil </span><span class="cov8" title="1">{
                return nil, ErrNotConnected
        }</span>
        
        <span class="cov8" title="1">vals, err := c.client.MGet(ctx, keys...).Result()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov8" title="1">result := make(map[string]interface{}, len(keys))
        for i, val := range vals </span><span class="cov8" title="1">{
                if val != nil </span><span class="cov8" title="1">{
                        var value interface{}
                        if str, ok := val.(string); ok </span><span class="cov8" title="1">{
                                if err := json.Unmarshal([]byte(str), &amp;value); err == nil </span><span class="cov8" title="1">{
                                        result[keys[i]] = value
                                }</span>
                        }
                }
        }
        
        <span class="cov8" title="1">return result, nil</span>
}

// SetMulti stores multiple items in the Redis cache with a TTL
func (c *RedisCache) SetMulti(ctx context.Context, items map[string]interface{}, ttl time.Duration) error <span class="cov8" title="1">{
        if len(items) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        
        <span class="cov8" title="1">if c.client == nil </span><span class="cov8" title="1">{
                return ErrNotConnected
        }</span>
        
        <span class="cov8" title="1">pipe := c.client.Pipeline()
        for key, value := range items </span><span class="cov8" title="1">{
                data, err := json.Marshal(value)
                if err != nil </span><span class="cov8" title="1">{
                        return ErrInvalidValue
                }</span>
                <span class="cov8" title="1">pipe.Set(ctx, key, data, ttl)</span>
        }
        
        <span class="cov8" title="1">_, err := pipe.Exec(ctx)
        return err</span>
}

// DeleteMulti removes multiple items from the Redis cache
func (c *RedisCache) DeleteMulti(ctx context.Context, keys []string) error <span class="cov8" title="1">{
        if len(keys) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        
        <span class="cov8" title="1">if c.client == nil </span><span class="cov8" title="1">{
                return ErrNotConnected
        }</span>
        
        <span class="cov8" title="1">return c.client.Del(ctx, keys...).Err()</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
