[1;37mFeature:[0m Application Lifecycle Management
  As a developer using the Modular framework
  I want to manage application lifecycle (initialization, startup, shutdown)
  So that I can build robust modular applications

  [1;37mBackground:[0m
    [32mGiven[0m [32mI have a new modular application[0m              [1;30m# application_lifecycle_bdd_test.go:408 -> *BDDTestContext[0m
    [32mAnd[0m [32mI have a logger configured[0m                      [1;30m# application_lifecycle_bdd_test.go:409 -> *BDDTestContext[0m

  [1;37mScenario:[0m Create a new application                    [1;30m# features/application_lifecycle.feature:10[0m
    [32mWhen[0m [32mI create a new standard application[0m            [1;30m# application_lifecycle_bdd_test.go:412 -> *BDDTestContext[0m
    [32mThen[0m [32mthe application should be properly initialized[0m [1;30m# application_lifecycle_bdd_test.go:413 -> *BDDTestContext[0m
    [32mAnd[0m [32mthe service registry should be empty[0m            [1;30m# application_lifecycle_bdd_test.go:414 -> *BDDTestContext[0m
    [32mAnd[0m [32mthe module registry should be empty[0m             [1;30m# application_lifecycle_bdd_test.go:415 -> *BDDTestContext[0m

  [1;37mScenario:[0m Register a simple module                            [1;30m# features/application_lifecycle.feature:16[0m
    [32mGiven[0m [32mI have a simple test module[0m                           [1;30m# application_lifecycle_bdd_test.go:418 -> *BDDTestContext[0m
    [32mWhen[0m [32mI register the module with the application[0m             [1;30m# application_lifecycle_bdd_test.go:419 -> *BDDTestContext[0m
    [32mThen[0m [32mthe module should be registered in the module registry[0m [1;30m# application_lifecycle_bdd_test.go:420 -> *BDDTestContext[0m
    [32mAnd[0m [32mthe module should not be initialized yet[0m                [1;30m# application_lifecycle_bdd_test.go:421 -> *BDDTestContext[0m

  [1;37mScenario:[0m Initialize application with modules                  [1;30m# features/application_lifecycle.feature:22[0m
    [32mGiven[0m [32mI have registered a simple test module[0m                 [1;30m# application_lifecycle_bdd_test.go:424 -> *BDDTestContext[0m
    [32mWhen[0m [32mI initialize the application[0m                            [1;30m# application_lifecycle_bdd_test.go:425 -> *BDDTestContext[0m
    [32mThen[0m [32mthe module should be initialized[0m                        [1;30m# application_lifecycle_bdd_test.go:426 -> *BDDTestContext[0m
    [32mAnd[0m [32many services provided by the module should be registered[0m [1;30m# application_lifecycle_bdd_test.go:427 -> *BDDTestContext[0m

  [1;37mScenario:[0m Initialize application with module dependencies              [1;30m# features/application_lifecycle.feature:28[0m
    [32mGiven[0m [32mI have a provider module that provides a service[0m               [1;30m# application_lifecycle_bdd_test.go:430 -> *BDDTestContext[0m
    [32mAnd[0m [32mI have a consumer module that depends on that service[0m            [1;30m# application_lifecycle_bdd_test.go:431 -> *BDDTestContext[0m
    [32mWhen[0m [32mI register both modules with the application[0m                    [1;30m# application_lifecycle_bdd_test.go:432 -> *BDDTestContext[0m
    [32mAnd[0m [32mI initialize the application[0m                                     [1;30m# application_lifecycle_bdd_test.go:425 -> *BDDTestContext[0m
    [32mThen[0m [32mboth modules should be initialized in dependency order[0m          [1;30m# application_lifecycle_bdd_test.go:433 -> *BDDTestContext[0m
    [32mAnd[0m [32mthe consumer module should receive the service from the provider[0m [1;30m# application_lifecycle_bdd_test.go:434 -> *BDDTestContext[0m

  [1;37mScenario:[0m Start and stop application with startable modules [1;30m# features/application_lifecycle.feature:36[0m
    [32mGiven[0m [32mI have a startable test module[0m                      [1;30m# application_lifecycle_bdd_test.go:437 -> *BDDTestContext[0m
    [32mAnd[0m [32mthe module is registered and initialized[0m              [1;30m# application_lifecycle_bdd_test.go:438 -> *BDDTestContext[0m
    [32mWhen[0m [32mI start the application[0m                              [1;30m# application_lifecycle_bdd_test.go:439 -> *BDDTestContext[0m
    [32mThen[0m [32mthe startable module should be started[0m               [1;30m# application_lifecycle_bdd_test.go:440 -> *BDDTestContext[0m
    [32mWhen[0m [32mI stop the application[0m                               [1;30m# application_lifecycle_bdd_test.go:441 -> *BDDTestContext[0m
    [32mThen[0m [32mthe startable module should be stopped[0m               [1;30m# application_lifecycle_bdd_test.go:442 -> *BDDTestContext[0m

  [1;37mScenario:[0m Handle module initialization errors                    [1;30m# features/application_lifecycle.feature:44[0m
    [32mGiven[0m [32mI have a module that fails during initialization[0m         [1;30m# application_lifecycle_bdd_test.go:445 -> *BDDTestContext[0m
    [32mWhen[0m [32mI try to initialize the application[0m                       [1;30m# application_lifecycle_bdd_test.go:446 -> *BDDTestContext[0m
    [32mThen[0m [32mthe initialization should fail[0m                            [1;30m# application_lifecycle_bdd_test.go:447 -> *BDDTestContext[0m
    [32mAnd[0m [32mthe error should include details about which module failed[0m [1;30m# application_lifecycle_bdd_test.go:448 -> *BDDTestContext[0m

  [1;37mScenario:[0m Handle circular dependencies                [1;30m# features/application_lifecycle.feature:50[0m
    [32mGiven[0m [32mI have two modules with circular dependencies[0m [1;30m# application_lifecycle_bdd_test.go:451 -> *BDDTestContext[0m
    [32mWhen[0m [32mI try to initialize the application[0m            [1;30m# application_lifecycle_bdd_test.go:446 -> *BDDTestContext[0m
    [32mThen[0m [32mthe initialization should fail[0m                 [1;30m# application_lifecycle_bdd_test.go:447 -> *BDDTestContext[0m
    [32mAnd[0m [32mthe error should indicate circular dependency[0m   [1;30m# application_lifecycle_bdd_test.go:452 -> *BDDTestContext[0m

7 scenarios ([32m7 passed[0m)
46 steps ([32m46 passed[0m)
6.269205ms
2025/09/07 08:30:39 INFO Starting module module=failing
2025/09/07 08:30:39 INFO Stopping module module=failing
2025/09/07 08:30:39 ERROR Error stopping module module=failing error="module stop failed"
[1;37mFeature:[0m Base Configuration Support
  As a developer using the Modular framework
  I want to use base configuration files with environment-specific overrides
  So that I can manage configuration for multiple environments efficiently

  [1;37mBackground:[0m
    [32mGiven[0m [32mI have a base config structure with environment "prod"[0m          [1;30m# base_config_bdd_test.go:226 -> *BaseConfigBDDTestContext[0m

  [1;37mScenario:[0m Basic base config with environment overrides                  [1;30m# features/base_config.feature:9[0m
    [32mGiven[0m [32mthe base config contains:[0m                                       [1;30m# base_config_bdd_test.go:227 -> *BaseConfigBDDTestContext[0m
      [36m"""[0m
      [36mapp_name: "MyApp"[0m
      [36menvironment: "base"[0m
      [36mdatabase:[0m
      [36m  host: "localhost"[0m
      [36m  port: 5432[0m
      [36m  name: "myapp"[0m
      [36m  username: "user"[0m
      [36m  password: "password"[0m
      [36mfeatures:[0m
      [36m  logging: true[0m
      [36m  metrics: false[0m
      [36m  caching: true[0m
      [36m"""[0m
    [32mAnd[0m [32mthe environment config contains:[0m                                  [1;30m# base_config_bdd_test.go:228 -> *BaseConfigBDDTestContext[0m
      [36m"""[0m
      [36menvironment: "production"[0m
      [36mdatabase:[0m
      [36m  host: "prod-db.example.com"[0m
      [36m  password: "prod-secret"[0m
      [36mfeatures:[0m
      [36m  metrics: true[0m
      [36m"""[0m
    [32mWhen[0m [32mI set the environment to "prod" and load the configuration[0m       [1;30m# base_config_bdd_test.go:229 -> *BaseConfigBDDTestContext[0m
    [32mThen[0m [32mthe configuration loading should succeed[0m                         [1;30m# base_config_bdd_test.go:238 -> *BaseConfigBDDTestContext[0m
    [32mAnd[0m [32mthe configuration should have app name "MyApp"[0m                    [1;30m# base_config_bdd_test.go:230 -> *BaseConfigBDDTestContext[0m
    [32mAnd[0m [32mthe configuration should have environment "production"[0m            [1;30m# base_config_bdd_test.go:231 -> *BaseConfigBDDTestContext[0m
    [32mAnd[0m [32mthe configuration should have database host "prod-db.example.com"[0m [1;30m# base_config_bdd_test.go:232 -> *BaseConfigBDDTestContext[0m
    [32mAnd[0m [32mthe configuration should have database password "prod-secret"[0m     [1;30m# base_config_bdd_test.go:233 -> *BaseConfigBDDTestContext[0m
    [32mAnd[0m [32mthe feature "logging" should be enabled[0m                           [1;30m# base_config_bdd_test.go:234 -> *BaseConfigBDDTestContext[0m
    [32mAnd[0m [32mthe feature "metrics" should be enabled[0m                           [1;30m# base_config_bdd_test.go:234 -> *BaseConfigBDDTestContext[0m
    [32mAnd[0m [32mthe feature "caching" should be enabled[0m                           [1;30m# base_config_bdd_test.go:234 -> *BaseConfigBDDTestContext[0m

  [1;37mScenario:[0m Base config only (no environment overrides)                    [1;30m# features/base_config.feature:44[0m
    [32mGiven[0m [32mthe base config contains:[0m                                        [1;30m# base_config_bdd_test.go:227 -> *BaseConfigBDDTestContext[0m
      [36m"""[0m
      [36mapp_name: "BaseApp"[0m
      [36menvironment: "development"[0m
      [36mdatabase:[0m
      [36m  host: "localhost"[0m
      [36m  port: 5432[0m
      [36mfeatures:[0m
      [36m  logging: true[0m
      [36m  metrics: false[0m
      [36m"""[0m
    [32mWhen[0m [32mI set the environment to "nonexistent" and load the configuration[0m [1;30m# base_config_bdd_test.go:229 -> *BaseConfigBDDTestContext[0m
    [32mThen[0m [32mthe configuration loading should succeed[0m                          [1;30m# base_config_bdd_test.go:238 -> *BaseConfigBDDTestContext[0m
    [32mAnd[0m [32mthe configuration should have app name "BaseApp"[0m                   [1;30m# base_config_bdd_test.go:230 -> *BaseConfigBDDTestContext[0m
    [32mAnd[0m [32mthe configuration should have environment "development"[0m            [1;30m# base_config_bdd_test.go:231 -> *BaseConfigBDDTestContext[0m
    [32mAnd[0m [32mthe configuration should have database host "localhost"[0m            [1;30m# base_config_bdd_test.go:232 -> *BaseConfigBDDTestContext[0m
    [32mAnd[0m [32mthe feature "logging" should be enabled[0m                            [1;30m# base_config_bdd_test.go:234 -> *BaseConfigBDDTestContext[0m
    [32mAnd[0m [32mthe feature "metrics" should be disabled[0m                           [1;30m# base_config_bdd_test.go:235 -> *BaseConfigBDDTestContext[0m

  [1;37mScenario:[0m Environment overrides only (no base config)                   [1;30m# features/base_config.feature:64[0m
    [32mGiven[0m [32mthe environment config contains:[0m                                [1;30m# base_config_bdd_test.go:228 -> *BaseConfigBDDTestContext[0m
      [36m"""[0m
      [36mapp_name: "ProdApp"[0m
      [36menvironment: "production"[0m
      [36mdatabase:[0m
      [36m  host: "prod-db.example.com"[0m
      [36m  port: 3306[0m
      [36mfeatures:[0m
      [36m  logging: false[0m
      [36m  metrics: true[0m
      [36m"""[0m
    [32mWhen[0m [32mI set the environment to "prod" and load the configuration[0m       [1;30m# base_config_bdd_test.go:229 -> *BaseConfigBDDTestContext[0m
    [32mThen[0m [32mthe configuration loading should succeed[0m                         [1;30m# base_config_bdd_test.go:238 -> *BaseConfigBDDTestContext[0m
    [32mAnd[0m [32mthe configuration should have app name "ProdApp"[0m                  [1;30m# base_config_bdd_test.go:230 -> *BaseConfigBDDTestContext[0m
    [32mAnd[0m [32mthe configuration should have environment "production"[0m            [1;30m# base_config_bdd_test.go:231 -> *BaseConfigBDDTestContext[0m
    [32mAnd[0m [32mthe configuration should have database host "prod-db.example.com"[0m [1;30m# base_config_bdd_test.go:232 -> *BaseConfigBDDTestContext[0m
    [32mAnd[0m [32mthe feature "logging" should be disabled[0m                          [1;30m# base_config_bdd_test.go:235 -> *BaseConfigBDDTestContext[0m
    [32mAnd[0m [32mthe feature "metrics" should be enabled[0m                           [1;30m# base_config_bdd_test.go:234 -> *BaseConfigBDDTestContext[0m

  [1;37mScenario:[0m Deep merge of nested configurations                     [1;30m# features/base_config.feature:84[0m
    [32mGiven[0m [32mthe base config contains:[0m                                 [1;30m# base_config_bdd_test.go:227 -> *BaseConfigBDDTestContext[0m
      [36m"""[0m
      [36mdatabase:[0m
      [36m  host: "base-host"[0m
      [36m  port: 5432[0m
      [36m  name: "base-db"[0m
      [36m  username: "base-user"[0m
      [36m  password: "base-pass"[0m
      [36mfeatures:[0m
      [36m  feature1: true[0m
      [36m  feature2: false[0m
      [36m  feature3: true[0m
      [36m"""[0m
    [32mAnd[0m [32mthe environment config contains:[0m                            [1;30m# base_config_bdd_test.go:228 -> *BaseConfigBDDTestContext[0m
      [36m"""[0m
      [36mdatabase:[0m
      [36m  host: "prod-host"[0m
      [36m  password: "prod-pass"[0m
      [36mfeatures:[0m
      [36m  feature2: true[0m
      [36m  feature4: true[0m
      [36m"""[0m
    [32mWhen[0m [32mI set the environment to "prod" and load the configuration[0m [1;30m# base_config_bdd_test.go:229 -> *BaseConfigBDDTestContext[0m
    [32mThen[0m [32mthe configuration loading should succeed[0m                   [1;30m# base_config_bdd_test.go:238 -> *BaseConfigBDDTestContext[0m
    [32mAnd[0m [32mthe configuration should have database host "prod-host"[0m     [1;30m# base_config_bdd_test.go:232 -> *BaseConfigBDDTestContext[0m
    [32mAnd[0m [32mthe configuration should have database password "prod-pass"[0m [1;30m# base_config_bdd_test.go:233 -> *BaseConfigBDDTestContext[0m
    [32mAnd[0m [32mthe feature "feature1" should be enabled[0m                    [1;30m# base_config_bdd_test.go:234 -> *BaseConfigBDDTestContext[0m
    [32mAnd[0m [32mthe feature "feature2" should be enabled[0m                    [1;30m# base_config_bdd_test.go:234 -> *BaseConfigBDDTestContext[0m
    [32mAnd[0m [32mthe feature "feature3" should be enabled[0m                    [1;30m# base_config_bdd_test.go:234 -> *BaseConfigBDDTestContext[0m
    [32mAnd[0m [32mthe feature "feature4" should be enabled[0m                    [1;30m# base_config_bdd_test.go:234 -> *BaseConfigBDDTestContext[0m

4 scenarios ([32m4 passed[0m)
41 steps ([32m41 passed[0m)
5.115595ms
[1;37mFeature:[0m Configuration Management
  As a developer using the Modular framework
  I want to manage configuration loading, validation, and feeding
  So that I can configure my modular applications properly

  [1;37mBackground:[0m
    [32mGiven[0m [32mI have a new modular application[0m                   [1;30m# configuration_management_bdd_test.go:507 -> *ConfigBDDTestContext[0m
    [32mAnd[0m [32mI have a logger configured[0m                           [1;30m# configuration_management_bdd_test.go:508 -> *ConfigBDDTestContext[0m

  [1;37mScenario:[0m Register module configuration                    [1;30m# features/configuration_management.feature:10[0m
    [32mGiven[0m [32mI have a module with configuration requirements[0m    [1;30m# configuration_management_bdd_test.go:511 -> *ConfigBDDTestContext[0m
    [32mWhen[0m [32mI register the module's configuration[0m               [1;30m# configuration_management_bdd_test.go:512 -> *ConfigBDDTestContext[0m
    [32mThen[0m [32mthe configuration should be registered successfully[0m [1;30m# configuration_management_bdd_test.go:513 -> *ConfigBDDTestContext[0m
    [32mAnd[0m [32mthe configuration should be available for the module[0m [1;30m# configuration_management_bdd_test.go:514 -> *ConfigBDDTestContext[0m

  [1;37mScenario:[0m Load configuration from environment variables              [1;30m# features/configuration_management.feature:16[0m
    [32mGiven[0m [32mI have environment variables set for module configuration[0m    [1;30m# configuration_management_bdd_test.go:517 -> *ConfigBDDTestContext[0m
    [32mAnd[0m [32mI have a module that requires configuration[0m                    [1;30m# configuration_management_bdd_test.go:518 -> *ConfigBDDTestContext[0m
    [32mWhen[0m [32mI load configuration using environment feeder[0m                 [1;30m# configuration_management_bdd_test.go:519 -> *ConfigBDDTestContext[0m
    [32mThen[0m [32mthe module configuration should be populated from environment[0m [1;30m# configuration_management_bdd_test.go:520 -> *ConfigBDDTestContext[0m
    [32mAnd[0m [32mthe configuration should pass validation[0m                       [1;30m# configuration_management_bdd_test.go:521 -> *ConfigBDDTestContext[0m

  [1;37mScenario:[0m Load configuration from YAML file                   [1;30m# features/configuration_management.feature:23[0m
    [32mGiven[0m [32mI have a YAML configuration file[0m                      [1;30m# configuration_management_bdd_test.go:524 -> *ConfigBDDTestContext[0m
    [32mAnd[0m [32mI have a module that requires configuration[0m             [1;30m# configuration_management_bdd_test.go:518 -> *ConfigBDDTestContext[0m
    [32mWhen[0m [32mI load configuration using YAML feeder[0m                 [1;30m# configuration_management_bdd_test.go:525 -> *ConfigBDDTestContext[0m
    [32mThen[0m [32mthe module configuration should be populated from YAML[0m [1;30m# configuration_management_bdd_test.go:526 -> *ConfigBDDTestContext[0m
    [32mAnd[0m [32mthe configuration should pass validation[0m                [1;30m# configuration_management_bdd_test.go:521 -> *ConfigBDDTestContext[0m

  [1;37mScenario:[0m Load configuration from JSON file                   [1;30m# features/configuration_management.feature:30[0m
    [32mGiven[0m [32mI have a JSON configuration file[0m                      [1;30m# configuration_management_bdd_test.go:529 -> *ConfigBDDTestContext[0m
    [32mAnd[0m [32mI have a module that requires configuration[0m             [1;30m# configuration_management_bdd_test.go:518 -> *ConfigBDDTestContext[0m
    [32mWhen[0m [32mI load configuration using JSON feeder[0m                 [1;30m# configuration_management_bdd_test.go:530 -> *ConfigBDDTestContext[0m
    [32mThen[0m [32mthe module configuration should be populated from JSON[0m [1;30m# configuration_management_bdd_test.go:531 -> *ConfigBDDTestContext[0m
    [32mAnd[0m [32mthe configuration should pass validation[0m                [1;30m# configuration_management_bdd_test.go:521 -> *ConfigBDDTestContext[0m

  [1;37mScenario:[0m Configuration validation with valid data          [1;30m# features/configuration_management.feature:37[0m
    [32mGiven[0m [32mI have a module with configuration validation rules[0m [1;30m# configuration_management_bdd_test.go:534 -> *ConfigBDDTestContext[0m
    [32mAnd[0m [32mI have valid configuration data[0m                       [1;30m# configuration_management_bdd_test.go:535 -> *ConfigBDDTestContext[0m
    [32mWhen[0m [32mI validate the configuration[0m                         [1;30m# configuration_management_bdd_test.go:536 -> *ConfigBDDTestContext[0m
    [32mThen[0m [32mthe validation should pass[0m                           [1;30m# configuration_management_bdd_test.go:537 -> *ConfigBDDTestContext[0m
    [32mAnd[0m [32mno validation errors should be reported[0m               [1;30m# configuration_management_bdd_test.go:538 -> *ConfigBDDTestContext[0m

  [1;37mScenario:[0m Configuration validation with invalid data        [1;30m# features/configuration_management.feature:44[0m
    [32mGiven[0m [32mI have a module with configuration validation rules[0m [1;30m# configuration_management_bdd_test.go:534 -> *ConfigBDDTestContext[0m
    [32mAnd[0m [32mI have invalid configuration data[0m                     [1;30m# configuration_management_bdd_test.go:539 -> *ConfigBDDTestContext[0m
    [32mWhen[0m [32mI validate the configuration[0m                         [1;30m# configuration_management_bdd_test.go:536 -> *ConfigBDDTestContext[0m
    [32mThen[0m [32mthe validation should fail[0m                           [1;30m# configuration_management_bdd_test.go:540 -> *ConfigBDDTestContext[0m
    [32mAnd[0m [32mappropriate validation errors should be reported[0m      [1;30m# configuration_management_bdd_test.go:541 -> *ConfigBDDTestContext[0m

  [1;37mScenario:[0m Configuration with default values               [1;30m# features/configuration_management.feature:51[0m
    [32mGiven[0m [32mI have a module with default configuration values[0m [1;30m# configuration_management_bdd_test.go:544 -> *ConfigBDDTestContext[0m
    [32mWhen[0m [32mI load configuration without providing all values[0m  [1;30m# configuration_management_bdd_test.go:545 -> *ConfigBDDTestContext[0m
    [32mThen[0m [32mthe missing values should use defaults[0m             [1;30m# configuration_management_bdd_test.go:546 -> *ConfigBDDTestContext[0m
    [32mAnd[0m [32mthe configuration should be complete[0m                [1;30m# configuration_management_bdd_test.go:547 -> *ConfigBDDTestContext[0m

  [1;37mScenario:[0m Required configuration fields                    [1;30m# features/configuration_management.feature:57[0m
    [32mGiven[0m [32mI have a module with required configuration fields[0m [1;30m# configuration_management_bdd_test.go:550 -> *ConfigBDDTestContext[0m
    [32mWhen[0m [32mI load configuration without required values[0m        [1;30m# configuration_management_bdd_test.go:551 -> *ConfigBDDTestContext[0m
    [32mThen[0m [32mthe configuration loading should fail[0m               [1;30m# configuration_management_bdd_test.go:552 -> *ConfigBDDTestContext[0m
    [32mAnd[0m [32mthe error should indicate missing required fields[0m    [1;30m# configuration_management_bdd_test.go:553 -> *ConfigBDDTestContext[0m

  [1;37mScenario:[0m Configuration field tracking                            [1;30m# features/configuration_management.feature:63[0m
    [32mGiven[0m [32mI have a module with configuration field tracking enabled[0m [1;30m# configuration_management_bdd_test.go:556 -> *ConfigBDDTestContext[0m
    [32mWhen[0m [32mI load configuration from multiple sources[0m                 [1;30m# configuration_management_bdd_test.go:557 -> *ConfigBDDTestContext[0m
    [32mThen[0m [32mI should be able to track which fields were set[0m            [1;30m# configuration_management_bdd_test.go:558 -> *ConfigBDDTestContext[0m
    [32mAnd[0m [32mI should know the source of each configuration value[0m        [1;30m# configuration_management_bdd_test.go:559 -> *ConfigBDDTestContext[0m

9 scenarios ([32m9 passed[0m)
59 steps ([32m59 passed[0m)
7.448888ms

ðŸ” ==> DEBUG: All Module Interface Implementations <==
ðŸ” Debugging module 'problematic' (type: *modular.ProblematicModule)
   Memory address: 0xc0000109c0
   âŒ Configurable
   âŒ DependencyAware
   âœ… ServiceAware
   âœ… Startable
   âœ… Stoppable
   âœ… Constructable
   âœ… Module
   ðŸ“¦ Provides 0 services, Requires 0 services
   ðŸ—ï¸  Has constructor - this module may be replaced during injection!

ðŸ” Debugging module 'correct' (type: *modular.CorrectModule)
   Memory address: 0xc0000109d8
   âŒ Configurable
   âŒ DependencyAware
   âœ… ServiceAware
   âœ… Startable
   âœ… Stoppable
   âœ… Constructable
   âœ… Module
   ðŸ“¦ Provides 0 services, Requires 0 services
   ðŸ—ï¸  Has constructor - this module may be replaced during injection!


ðŸ” ==> DEBUG: All Module Interface Implementations <==
ðŸ” Debugging module 'problematic' (type: *modular.BrokenModuleImplementation)
   Memory address: 0xc000392150
   âœ… Module
   âŒ Configurable
   âŒ DependencyAware
   âŒ ServiceAware
   âŒ Startable
   âŒ Stoppable
   âŒ Constructable

ðŸ” Debugging module 'correct' (type: *modular.CorrectModule)
   Memory address: 0xc000010af8
   âœ… Module
   âŒ Configurable
   âŒ DependencyAware
   âœ… ServiceAware
   âœ… Startable
   âœ… Stoppable
   âœ… Constructable
   ðŸ“¦ Provides 0 services, Requires 0 services
   ðŸ—ï¸  Has constructor - this module may be replaced during injection!

[1;37mFeature:[0m Enhanced Cycle Detection
  As a developer using the Modular framework
  I want enhanced cycle detection with clear error messages including interface dependencies
  So that I can easily understand and fix circular dependency issues

  [1;37mBackground:[0m
    [32mGiven[0m [32mI have a modular application[0m                                   [1;30m# enhanced_cycle_detection_bdd_test.go:724 -> *EnhancedCycleDetectionBDDTestContext[0m

  [1;37mScenario:[0m Cycle detection with interface-based dependencies            [1;30m# features/enhanced_cycle_detection.feature:9[0m
    [32mGiven[0m [32mI have two modules with circular interface dependencies[0m        [1;30m# enhanced_cycle_detection_bdd_test.go:727 -> *EnhancedCycleDetectionBDDTestContext[0m
    [32mWhen[0m [32mI try to initialize the application[0m                             [1;30m# enhanced_cycle_detection_bdd_test.go:728 -> *EnhancedCycleDetectionBDDTestContext[0m
    [32mThen[0m [32mthe initialization should fail with a circular dependency error[0m [1;30m# enhanced_cycle_detection_bdd_test.go:729 -> *EnhancedCycleDetectionBDDTestContext[0m
    [32mAnd[0m [32mthe error message should include both module names[0m               [1;30m# enhanced_cycle_detection_bdd_test.go:730 -> *EnhancedCycleDetectionBDDTestContext[0m
    [32mAnd[0m [32mthe error message should indicate interface-based dependencies[0m   [1;30m# enhanced_cycle_detection_bdd_test.go:731 -> *EnhancedCycleDetectionBDDTestContext[0m
    [32mAnd[0m [32mthe error message should show the complete dependency cycle[0m      [1;30m# enhanced_cycle_detection_bdd_test.go:732 -> *EnhancedCycleDetectionBDDTestContext[0m

  [1;37mScenario:[0m Enhanced error message format                                                                                                  [1;30m# features/enhanced_cycle_detection.feature:17[0m
    [32mGiven[0m [32mI have modules A and B where A requires interface TestInterface and B provides TestInterface[0m                                     [1;30m# enhanced_cycle_detection_bdd_test.go:735 -> *EnhancedCycleDetectionBDDTestContext[0m
    [32mAnd[0m [32mmodule B also requires interface TestInterface creating a cycle[0m                                                                    [1;30m# enhanced_cycle_detection_bdd_test.go:736 -> *EnhancedCycleDetectionBDDTestContext[0m
    [32mWhen[0m [32mI try to initialize the application[0m                                                                                               [1;30m# enhanced_cycle_detection_bdd_test.go:728 -> *EnhancedCycleDetectionBDDTestContext[0m
    [32mThen[0m [32mthe error message should contain "cycle: moduleA â†’(interface:TestInterface) moduleB â†’ moduleB â†’(interface:TestInterface) moduleA"[0m [1;30m# enhanced_cycle_detection_bdd_test.go:737 -> *EnhancedCycleDetectionBDDTestContext[0m
    [32mAnd[0m [32mthe error message should clearly show the interface causing the cycle[0m                                                              [1;30m# enhanced_cycle_detection_bdd_test.go:738 -> *EnhancedCycleDetectionBDDTestContext[0m

  [1;37mScenario:[0m Mixed dependency types in cycle detection                                    [1;30m# features/enhanced_cycle_detection.feature:24[0m
    [32mGiven[0m [32mI have modules with both named service dependencies and interface dependencies[0m [1;30m# enhanced_cycle_detection_bdd_test.go:752 -> *EnhancedCycleDetectionBDDTestContext[0m
    [32mAnd[0m [32mthe dependencies form a circular chain[0m                                           [1;30m# enhanced_cycle_detection_bdd_test.go:753 -> *EnhancedCycleDetectionBDDTestContext[0m
    [32mWhen[0m [32mI try to initialize the application[0m                                             [1;30m# enhanced_cycle_detection_bdd_test.go:728 -> *EnhancedCycleDetectionBDDTestContext[0m
    [32mThen[0m [32mthe error message should distinguish between interface and named dependencies[0m   [1;30m# enhanced_cycle_detection_bdd_test.go:754 -> *EnhancedCycleDetectionBDDTestContext[0m
    [32mAnd[0m [32mboth dependency types should be included in the cycle description[0m                [1;30m# enhanced_cycle_detection_bdd_test.go:755 -> *EnhancedCycleDetectionBDDTestContext[0m

  [1;37mScenario:[0m No false positive cycle detection           [1;30m# features/enhanced_cycle_detection.feature:31[0m
    [32mGiven[0m [32mI have modules with valid linear dependencies[0m [1;30m# enhanced_cycle_detection_bdd_test.go:741 -> *EnhancedCycleDetectionBDDTestContext[0m
    [32mWhen[0m [32mI initialize the application[0m                   [1;30m# enhanced_cycle_detection_bdd_test.go:742 -> *EnhancedCycleDetectionBDDTestContext[0m
    [32mThen[0m [32mthe initialization should succeed[0m              [1;30m# enhanced_cycle_detection_bdd_test.go:743 -> *EnhancedCycleDetectionBDDTestContext[0m
    [32mAnd[0m [32mno circular dependency error should be reported[0m [1;30m# enhanced_cycle_detection_bdd_test.go:744 -> *EnhancedCycleDetectionBDDTestContext[0m

  [1;37mScenario:[0m Self-dependency detection                                 [1;30m# features/enhanced_cycle_detection.feature:37[0m
    [32mGiven[0m [32mI have a module that depends on a service it also provides[0m  [1;30m# enhanced_cycle_detection_bdd_test.go:747 -> *EnhancedCycleDetectionBDDTestContext[0m
    [32mWhen[0m [32mI try to initialize the application[0m                          [1;30m# enhanced_cycle_detection_bdd_test.go:728 -> *EnhancedCycleDetectionBDDTestContext[0m
    [32mThen[0m [32ma self-dependency cycle should be detected[0m                   [1;30m# enhanced_cycle_detection_bdd_test.go:748 -> *EnhancedCycleDetectionBDDTestContext[0m
    [32mAnd[0m [32mthe error message should clearly indicate the self-dependency[0m [1;30m# enhanced_cycle_detection_bdd_test.go:749 -> *EnhancedCycleDetectionBDDTestContext[0m

  [1;37mScenario:[0m Complex multi-module cycles                                                       [1;30m# features/enhanced_cycle_detection.feature:43[0m
    [32mGiven[0m [32mI have modules A, B, and C where A depends on B, B depends on C, and C depends on A[0m [1;30m# enhanced_cycle_detection_bdd_test.go:758 -> *EnhancedCycleDetectionBDDTestContext[0m
    [32mWhen[0m [32mI try to initialize the application[0m                                                  [1;30m# enhanced_cycle_detection_bdd_test.go:728 -> *EnhancedCycleDetectionBDDTestContext[0m
    [32mThen[0m [32mthe complete cycle path should be shown in the error message[0m                         [1;30m# enhanced_cycle_detection_bdd_test.go:759 -> *EnhancedCycleDetectionBDDTestContext[0m
    [32mAnd[0m [32mall three modules should be mentioned in the cycle description[0m                        [1;30m# enhanced_cycle_detection_bdd_test.go:760 -> *EnhancedCycleDetectionBDDTestContext[0m

  [1;37mScenario:[0m Interface name disambiguation                                   [1;30m# features/enhanced_cycle_detection.feature:49[0m
    [32mGiven[0m [32mI have multiple interfaces with similar names causing cycles[0m      [1;30m# enhanced_cycle_detection_bdd_test.go:763 -> *EnhancedCycleDetectionBDDTestContext[0m
    [32mWhen[0m [32mcycle detection runs[0m                                               [1;30m# enhanced_cycle_detection_bdd_test.go:764 -> *EnhancedCycleDetectionBDDTestContext[0m
    [32mThen[0m [32minterface names in error messages should be fully qualified[0m        [1;30m# enhanced_cycle_detection_bdd_test.go:765 -> *EnhancedCycleDetectionBDDTestContext[0m
    [32mAnd[0m [32mthere should be no ambiguity about which interface caused the cycle[0m [1;30m# enhanced_cycle_detection_bdd_test.go:766 -> *EnhancedCycleDetectionBDDTestContext[0m

7 scenarios ([32m7 passed[0m)
39 steps ([32m39 passed[0m)
5.125595ms
[1;37mFeature:[0m Enhanced Service Registry API
  As a developer using the Modular framework
  I want to use the enhanced service registry with interface-based discovery and automatic conflict resolution
  So that I can build more flexible and maintainable modular applications

  [1;37mBackground:[0m
    [32mGiven[0m [32mI have a modular application with enhanced service registry[0m          [1;30m# enhanced_service_registry_bdd_test.go:609 -> *EnhancedServiceRegistryBDDContext[0m

  [1;37mScenario:[0m Service registration with module tracking                          [1;30m# features/enhanced_service_registry.feature:9[0m
    [32mGiven[0m [32mI have a module "TestModule" that provides a service "testService"[0m   [1;30m# enhanced_service_registry_bdd_test.go:612 -> *EnhancedServiceRegistryBDDContext[0m
    [32mWhen[0m [32mI register the module and initialize the application[0m                  [1;30m# enhanced_service_registry_bdd_test.go:613 -> *EnhancedServiceRegistryBDDContext[0m
    [32mThen[0m [32mthe service should be registered with module association[0m              [1;30m# enhanced_service_registry_bdd_test.go:614 -> *EnhancedServiceRegistryBDDContext[0m
    [32mAnd[0m [32mI should be able to retrieve the service entry with module information[0m [1;30m# enhanced_service_registry_bdd_test.go:615 -> *EnhancedServiceRegistryBDDContext[0m

  [1;37mScenario:[0m Automatic conflict resolution with module suffixes                                    [1;30m# features/enhanced_service_registry.feature:15[0m
    [32mGiven[0m [32mI have two modules "ModuleA" and "ModuleB" that both provide service "duplicateService"[0m [1;30m# enhanced_service_registry_bdd_test.go:618 -> *EnhancedServiceRegistryBDDContext[0m
    [32mWhen[0m [32mI register both modules and initialize the application[0m                                   [1;30m# enhanced_service_registry_bdd_test.go:619 -> *EnhancedServiceRegistryBDDContext[0m
    [32mThen[0m [32mthe first module should keep the original service name[0m                                   [1;30m# enhanced_service_registry_bdd_test.go:620 -> *EnhancedServiceRegistryBDDContext[0m
    [32mAnd[0m [32mthe second module should get a module-suffixed name[0m                                       [1;30m# enhanced_service_registry_bdd_test.go:621 -> *EnhancedServiceRegistryBDDContext[0m
    [32mAnd[0m [32mboth services should be accessible through their resolved names[0m                           [1;30m# enhanced_service_registry_bdd_test.go:622 -> *EnhancedServiceRegistryBDDContext[0m

  [1;37mScenario:[0m Interface-based service discovery                                       [1;30m# features/enhanced_service_registry.feature:22[0m
    [32mGiven[0m [32mI have multiple modules providing services that implement "TestInterface"[0m [1;30m# enhanced_service_registry_bdd_test.go:625 -> *EnhancedServiceRegistryBDDContext[0m
    [32mWhen[0m [32mI query for services by interface type[0m                                     [1;30m# enhanced_service_registry_bdd_test.go:626 -> *EnhancedServiceRegistryBDDContext[0m
    [32mThen[0m [32mI should get all services implementing that interface[0m                      [1;30m# enhanced_service_registry_bdd_test.go:627 -> *EnhancedServiceRegistryBDDContext[0m
    [32mAnd[0m [32meach service should include its module association information[0m              [1;30m# enhanced_service_registry_bdd_test.go:628 -> *EnhancedServiceRegistryBDDContext[0m

  [1;37mScenario:[0m Get services provided by specific module                                      [1;30m# features/enhanced_service_registry.feature:28[0m
    [32mGiven[0m [32mI have modules "ModuleA", "ModuleB", and "ModuleC" providing different services[0m [1;30m# enhanced_service_registry_bdd_test.go:631 -> *EnhancedServiceRegistryBDDContext[0m
    [32mWhen[0m [32mI query for services provided by "ModuleB"[0m                                       [1;30m# enhanced_service_registry_bdd_test.go:632 -> *EnhancedServiceRegistryBDDContext[0m
    [32mThen[0m [32mI should get only the services registered by "ModuleB"[0m                           [1;30m# enhanced_service_registry_bdd_test.go:633 -> *EnhancedServiceRegistryBDDContext[0m
    [32mAnd[0m [32mthe service names should reflect any conflict resolution applied[0m                  [1;30m# enhanced_service_registry_bdd_test.go:634 -> *EnhancedServiceRegistryBDDContext[0m

  [1;37mScenario:[0m Service entry with detailed information                                            [1;30m# features/enhanced_service_registry.feature:34[0m
    [32mGiven[0m [32mI have a service "detailedService" registered by module "DetailModule"[0m               [1;30m# enhanced_service_registry_bdd_test.go:637 -> *EnhancedServiceRegistryBDDContext[0m
    [32mWhen[0m [32mI retrieve the service entry by name[0m                                                  [1;30m# enhanced_service_registry_bdd_test.go:638 -> *EnhancedServiceRegistryBDDContext[0m
    [32mThen[0m [32mthe entry should contain the original name, actual name, module name, and module type[0m [1;30m# enhanced_service_registry_bdd_test.go:639 -> *EnhancedServiceRegistryBDDContext[0m
    [32mAnd[0m [32mI should be able to access the actual service instance[0m                                 [1;30m# enhanced_service_registry_bdd_test.go:640 -> *EnhancedServiceRegistryBDDContext[0m

  [1;37mScenario:[0m Backwards compatibility with existing service registry           [1;30m# features/enhanced_service_registry.feature:40[0m
    [32mGiven[0m [32mI have services registered through both old and new patterns[0m       [1;30m# enhanced_service_registry_bdd_test.go:643 -> *EnhancedServiceRegistryBDDContext[0m
    [32mWhen[0m [32mI access services through the backwards-compatible interface[0m        [1;30m# enhanced_service_registry_bdd_test.go:644 -> *EnhancedServiceRegistryBDDContext[0m
    [32mThen[0m [32mall services should be accessible regardless of registration method[0m [1;30m# enhanced_service_registry_bdd_test.go:645 -> *EnhancedServiceRegistryBDDContext[0m
    [32mAnd[0m [32mthe service registry map should contain all services[0m                 [1;30m# enhanced_service_registry_bdd_test.go:646 -> *EnhancedServiceRegistryBDDContext[0m

  [1;37mScenario:[0m Multiple interface implementations conflict resolution                   [1;30m# features/enhanced_service_registry.feature:46[0m
    [32mGiven[0m [32mI have three modules providing services implementing the same interface[0m    [1;30m# enhanced_service_registry_bdd_test.go:649 -> *EnhancedServiceRegistryBDDContext[0m
    [32mAnd[0m [32mall modules attempt to register with the same service name[0m                   [1;30m# enhanced_service_registry_bdd_test.go:650 -> *EnhancedServiceRegistryBDDContext[0m
    [32mWhen[0m [32mthe application initializes[0m                                                 [1;30m# enhanced_service_registry_bdd_test.go:651 -> *EnhancedServiceRegistryBDDContext[0m
    [32mThen[0m [32meach service should get a unique name through automatic conflict resolution[0m [1;30m# enhanced_service_registry_bdd_test.go:652 -> *EnhancedServiceRegistryBDDContext[0m
    [32mAnd[0m [32mall services should be discoverable by interface[0m                             [1;30m# enhanced_service_registry_bdd_test.go:653 -> *EnhancedServiceRegistryBDDContext[0m

  [1;37mScenario:[0m Enhanced service registry handles edge cases                                [1;30m# features/enhanced_service_registry.feature:53[0m
    [32mGiven[0m [32mI have a module that provides multiple services with potential name conflicts[0m [1;30m# enhanced_service_registry_bdd_test.go:656 -> *EnhancedServiceRegistryBDDContext[0m
    [32mWhen[0m [32mthe module registers services with similar names[0m                               [1;30m# enhanced_service_registry_bdd_test.go:657 -> *EnhancedServiceRegistryBDDContext[0m
    [32mThen[0m [32mthe enhanced registry should resolve all conflicts intelligently[0m               [1;30m# enhanced_service_registry_bdd_test.go:658 -> *EnhancedServiceRegistryBDDContext[0m
    [32mAnd[0m [32meach service should maintain its module association[0m                             [1;30m# enhanced_service_registry_bdd_test.go:659 -> *EnhancedServiceRegistryBDDContext[0m

8 scenarios ([32m8 passed[0m)
42 steps ([32m42 passed[0m)
7.098288ms
time=2025-09-07T08:30:39.800Z level=DEBUG msg="Registered service" name=tenantService actualName=tenantService type=*modular.StandardTenantService
time=2025-09-07T08:30:39.800Z level=DEBUG msg="Registered service" name=tenantConfigLoader actualName=tenantConfigLoader type=*modular.SimpleTenantConfigLoader
time=2025-09-07T08:30:39.800Z level=DEBUG msg="Module does not implement Configurable, skipping" module=MockTenantAwareModule
time=2025-09-07T08:30:39.800Z level=DEBUG msg="Added main config for loading" type="*struct {}"
time=2025-09-07T08:30:39.800Z level=DEBUG msg="Updated main config"
time=2025-09-07T08:30:39.801Z level=DEBUG msg="Module does not implement DependencyAware, skipping" module=MockTenantAwareModule
time=2025-09-07T08:30:39.801Z level=DEBUG msg="Module initialization order" order=[MockTenantAwareModule]
time=2025-09-07T08:30:39.801Z level=INFO msg="Initialized module MockTenantAwareModule of type *modular.MockTenantAwareModule"
time=2025-09-07T08:30:39.801Z level=DEBUG msg="Loading tenant configurations using TenantConfigLoader"
time=2025-09-07T08:30:39.801Z level=INFO msg="Loading tenant configurations"
time=2025-09-07T08:30:39.801Z level=DEBUG msg="Registering config for tenant" tenantID=test-tenant section=MockTenantAwareModule
time=2025-09-07T08:30:39.801Z level=INFO msg="Registered tenant" tenantID=test-tenant
time=2025-09-07T08:30:39.801Z level=DEBUG msg="Registered tenant-aware module" module=*modular.MockTenantAwareModule name=MockTenantAwareModule
time=2025-09-07T08:30:39.801Z level=INFO msg="Tenant registered in mock module" tenantID=test-tenant
time=2025-09-07T08:30:39.801Z level=DEBUG msg="Notified module about tenant" module=*modular.MockTenantAwareModule tenantID=test-tenant
[1;37mFeature:[0m Logger Decorator Pattern
  As a developer using the Modular framework
  I want to compose multiple logging behaviors using decorators
  So that I can create flexible and powerful logging systems

  [1;37mBackground:[0m
    [32mGiven[0m [32mI have a new modular application[0m                         [1;30m# logger_decorator_bdd_test.go:525 -> *LoggerDecoratorBDDTestContext[0m
    [32mAnd[0m [32mI have a test logger configured[0m                            [1;30m# logger_decorator_bdd_test.go:526 -> *LoggerDecoratorBDDTestContext[0m

  [1;37mScenario:[0m Single decorator - prefix logger                       [1;30m# features/logger_decorator.feature:10[0m
    [32mGiven[0m [32mI have a base logger[0m                                     [1;30m# logger_decorator_bdd_test.go:529 -> *LoggerDecoratorBDDTestContext[0m
    [32mWhen[0m [32mI apply a prefix decorator with prefix "[MODULE]"[0m         [1;30m# logger_decorator_bdd_test.go:536 -> *LoggerDecoratorBDDTestContext[0m
    [32mAnd[0m [32mI log an info message "test message"[0m                       [1;30m# logger_decorator_bdd_test.go:547 -> *LoggerDecoratorBDDTestContext[0m
    [32mThen[0m [32mthe logged message should contain "[MODULE] test message"[0m [1;30m# logger_decorator_bdd_test.go:559 -> *LoggerDecoratorBDDTestContext[0m

  [1;37mScenario:[0m Single decorator - value injection                                                     [1;30m# features/logger_decorator.feature:16[0m
    [32mGiven[0m [32mI have a base logger[0m                                                                     [1;30m# logger_decorator_bdd_test.go:529 -> *LoggerDecoratorBDDTestContext[0m
    [32mWhen[0m [32mI apply a value injection decorator with "service", "test-service" and "version", "1.0.0"[0m [1;30m# logger_decorator_bdd_test.go:538 -> *LoggerDecoratorBDDTestContext[0m
    [32mAnd[0m [32mI log an info message "test message" with args "key", "value"[0m                              [1;30m# logger_decorator_bdd_test.go:548 -> *LoggerDecoratorBDDTestContext[0m
    [32mThen[0m [32mthe logged args should contain "service": "test-service"[0m                                  [1;30m# logger_decorator_bdd_test.go:560 -> *LoggerDecoratorBDDTestContext[0m
    [32mAnd[0m [32mthe logged args should contain "version": "1.0.0"[0m                                          [1;30m# logger_decorator_bdd_test.go:560 -> *LoggerDecoratorBDDTestContext[0m
    [32mAnd[0m [32mthe logged args should contain "key": "value"[0m                                              [1;30m# logger_decorator_bdd_test.go:560 -> *LoggerDecoratorBDDTestContext[0m

  [1;37mScenario:[0m Single decorator - dual writer                                 [1;30m# features/logger_decorator.feature:24[0m
    [32mGiven[0m [32mI have a primary test logger[0m                                     [1;30m# logger_decorator_bdd_test.go:530 -> *LoggerDecoratorBDDTestContext[0m
    [32mAnd[0m [32mI have a secondary test logger[0m                                     [1;30m# logger_decorator_bdd_test.go:531 -> *LoggerDecoratorBDDTestContext[0m
    [32mWhen[0m [32mI apply a dual writer decorator[0m                                   [1;30m# logger_decorator_bdd_test.go:539 -> *LoggerDecoratorBDDTestContext[0m
    [32mAnd[0m [32mI log an info message "dual message"[0m                               [1;30m# logger_decorator_bdd_test.go:547 -> *LoggerDecoratorBDDTestContext[0m
    [32mThen[0m [32mboth the primary and secondary loggers should receive the message[0m [1;30m# logger_decorator_bdd_test.go:561 -> *LoggerDecoratorBDDTestContext[0m

  [1;37mScenario:[0m Single decorator - filter logger                                 [1;30m# features/logger_decorator.feature:31[0m
    [32mGiven[0m [32mI have a base logger[0m                                               [1;30m# logger_decorator_bdd_test.go:529 -> *LoggerDecoratorBDDTestContext[0m
    [32mWhen[0m [32mI apply a filter decorator that blocks messages containing "secret"[0m [1;30m# logger_decorator_bdd_test.go:540 -> *LoggerDecoratorBDDTestContext[0m
    [32mAnd[0m [32mI log an info message "normal message"[0m                               [1;30m# logger_decorator_bdd_test.go:547 -> *LoggerDecoratorBDDTestContext[0m
    [32mAnd[0m [32mI log an info message "contains secret data"[0m                         [1;30m# logger_decorator_bdd_test.go:547 -> *LoggerDecoratorBDDTestContext[0m
    [32mThen[0m [32mthe base logger should have received 1 message[0m                      [1;30m# logger_decorator_bdd_test.go:562 -> *LoggerDecoratorBDDTestContext[0m
    [32mAnd[0m [32mthe logged message should be "normal message"[0m                        [1;30m# logger_decorator_bdd_test.go:563 -> *LoggerDecoratorBDDTestContext[0m

  [1;37mScenario:[0m Multiple decorators chained together                          [1;30m# features/logger_decorator.feature:39[0m
    [32mGiven[0m [32mI have a base logger[0m                                            [1;30m# logger_decorator_bdd_test.go:529 -> *LoggerDecoratorBDDTestContext[0m
    [32mWhen[0m [32mI apply a prefix decorator with prefix "[API]"[0m                   [1;30m# logger_decorator_bdd_test.go:536 -> *LoggerDecoratorBDDTestContext[0m
    [32mAnd[0m [32mI apply a value injection decorator with "service", "api-service"[0m [1;30m# logger_decorator_bdd_test.go:537 -> *LoggerDecoratorBDDTestContext[0m
    [32mAnd[0m [32mI apply a filter decorator that blocks debug level logs[0m           [1;30m# logger_decorator_bdd_test.go:541 -> *LoggerDecoratorBDDTestContext[0m
    [32mAnd[0m [32mI log an info message "processing request"[0m                        [1;30m# logger_decorator_bdd_test.go:547 -> *LoggerDecoratorBDDTestContext[0m
    [32mAnd[0m [32mI log a debug message "debug details"[0m                             [1;30m# logger_decorator_bdd_test.go:549 -> *LoggerDecoratorBDDTestContext[0m
    [32mThen[0m [32mthe base logger should have received 1 message[0m                   [1;30m# logger_decorator_bdd_test.go:562 -> *LoggerDecoratorBDDTestContext[0m
    [32mAnd[0m [32mthe logged message should contain "[API] processing request"[0m      [1;30m# logger_decorator_bdd_test.go:559 -> *LoggerDecoratorBDDTestContext[0m
    [32mAnd[0m [32mthe logged args should contain "service": "api-service"[0m           [1;30m# logger_decorator_bdd_test.go:560 -> *LoggerDecoratorBDDTestContext[0m

  [1;37mScenario:[0m Complex decorator chain - enterprise logging                                                   [1;30m# features/logger_decorator.feature:50[0m
    [32mGiven[0m [32mI have a primary test logger[0m                                                                     [1;30m# logger_decorator_bdd_test.go:530 -> *LoggerDecoratorBDDTestContext[0m
    [32mAnd[0m [32mI have an audit test logger[0m                                                                        [1;30m# logger_decorator_bdd_test.go:532 -> *LoggerDecoratorBDDTestContext[0m
    [32mWhen[0m [32mI apply a dual writer decorator[0m                                                                   [1;30m# logger_decorator_bdd_test.go:539 -> *LoggerDecoratorBDDTestContext[0m
    [32mAnd[0m [32mI apply a value injection decorator with "service", "payment-processor" and "instance", "prod-001"[0m [1;30m# logger_decorator_bdd_test.go:538 -> *LoggerDecoratorBDDTestContext[0m
    [32mAnd[0m [32mI apply a prefix decorator with prefix "[PAYMENT]"[0m                                                 [1;30m# logger_decorator_bdd_test.go:536 -> *LoggerDecoratorBDDTestContext[0m
    [32mAnd[0m [32mI apply a filter decorator that blocks messages containing "credit_card"[0m                           [1;30m# logger_decorator_bdd_test.go:540 -> *LoggerDecoratorBDDTestContext[0m
    [32mAnd[0m [32mI log an info message "payment processed" with args "amount", "99.99"[0m                              [1;30m# logger_decorator_bdd_test.go:548 -> *LoggerDecoratorBDDTestContext[0m
    [32mAnd[0m [32mI log an info message "credit_card validation failed"[0m                                              [1;30m# logger_decorator_bdd_test.go:547 -> *LoggerDecoratorBDDTestContext[0m
    [32mThen[0m [32mboth the primary and audit loggers should have received 1 message[0m                                 [1;30m# logger_decorator_bdd_test.go:564 -> *LoggerDecoratorBDDTestContext[0m
    [32mAnd[0m [32mthe logged message should contain "[PAYMENT] payment processed"[0m                                    [1;30m# logger_decorator_bdd_test.go:559 -> *LoggerDecoratorBDDTestContext[0m
    [32mAnd[0m [32mthe logged args should contain "service": "payment-processor"[0m                                      [1;30m# logger_decorator_bdd_test.go:560 -> *LoggerDecoratorBDDTestContext[0m
    [32mAnd[0m [32mthe logged args should contain "instance": "prod-001"[0m                                              [1;30m# logger_decorator_bdd_test.go:560 -> *LoggerDecoratorBDDTestContext[0m
    [32mAnd[0m [32mthe logged args should contain "amount": "99.99"[0m                                                   [1;30m# logger_decorator_bdd_test.go:560 -> *LoggerDecoratorBDDTestContext[0m

  [1;37mScenario:[0m SetLogger with decorators updates service registry          [1;30m# features/logger_decorator.feature:65[0m
    [32mGiven[0m [32mI have an initial test logger in the application[0m              [1;30m# logger_decorator_bdd_test.go:533 -> *LoggerDecoratorBDDTestContext[0m
    [32mWhen[0m [32mI create a decorated logger with prefix "[NEW]"[0m                [1;30m# logger_decorator_bdd_test.go:554 -> *LoggerDecoratorBDDTestContext[0m
    [32mAnd[0m [32mI set the decorated logger on the application[0m                   [1;30m# logger_decorator_bdd_test.go:555 -> *LoggerDecoratorBDDTestContext[0m
    [32mAnd[0m [32mI get the logger service from the application[0m                   [1;30m# logger_decorator_bdd_test.go:556 -> *LoggerDecoratorBDDTestContext[0m
    [32mAnd[0m [32mI log an info message "service registry test"[0m                   [1;30m# logger_decorator_bdd_test.go:547 -> *LoggerDecoratorBDDTestContext[0m
    [32mThen[0m [32mthe logger service should be the decorated logger[0m              [1;30m# logger_decorator_bdd_test.go:565 -> *LoggerDecoratorBDDTestContext[0m
    [32mAnd[0m [32mthe logged message should contain "[NEW] service registry test"[0m [1;30m# logger_decorator_bdd_test.go:559 -> *LoggerDecoratorBDDTestContext[0m

  [1;37mScenario:[0m Level modifier decorator promotes warnings to errors        [1;30m# features/logger_decorator.feature:74[0m
    [32mGiven[0m [32mI have a base logger[0m                                          [1;30m# logger_decorator_bdd_test.go:529 -> *LoggerDecoratorBDDTestContext[0m
    [32mWhen[0m [32mI apply a level modifier decorator that maps "warn" to "error"[0m [1;30m# logger_decorator_bdd_test.go:544 -> *LoggerDecoratorBDDTestContext[0m
    [32mAnd[0m [32mI log a warn message "high memory usage"[0m                        [1;30m# logger_decorator_bdd_test.go:550 -> *LoggerDecoratorBDDTestContext[0m
    [32mAnd[0m [32mI log an info message "normal operation"[0m                        [1;30m# logger_decorator_bdd_test.go:547 -> *LoggerDecoratorBDDTestContext[0m
    [32mThen[0m [32mthe base logger should have received 2 messages[0m                [1;30m# logger_decorator_bdd_test.go:562 -> *LoggerDecoratorBDDTestContext[0m
    [32mAnd[0m [32mthe first message should have level "error"[0m                     [1;30m# logger_decorator_bdd_test.go:566 -> *LoggerDecoratorBDDTestContext[0m
    [32mAnd[0m [32mthe second message should have level "info"[0m                     [1;30m# logger_decorator_bdd_test.go:567 -> *LoggerDecoratorBDDTestContext[0m

  [1;37mScenario:[0m Nested decorators preserve order                  [1;30m# features/logger_decorator.feature:83[0m
    [32mGiven[0m [32mI have a base logger[0m                                [1;30m# logger_decorator_bdd_test.go:529 -> *LoggerDecoratorBDDTestContext[0m
    [32mWhen[0m [32mI apply a prefix decorator with prefix "[L1]"[0m        [1;30m# logger_decorator_bdd_test.go:536 -> *LoggerDecoratorBDDTestContext[0m
    [32mAnd[0m [32mI apply a value injection decorator with "level", "2"[0m [1;30m# logger_decorator_bdd_test.go:537 -> *LoggerDecoratorBDDTestContext[0m
    [32mAnd[0m [32mI apply a prefix decorator with prefix "[L3]"[0m         [1;30m# logger_decorator_bdd_test.go:536 -> *LoggerDecoratorBDDTestContext[0m
    [32mAnd[0m [32mI log an info message "nested test"[0m                   [1;30m# logger_decorator_bdd_test.go:547 -> *LoggerDecoratorBDDTestContext[0m
    [32mThen[0m [32mthe logged message should be "[L1] [L3] nested test"[0m [1;30m# logger_decorator_bdd_test.go:563 -> *LoggerDecoratorBDDTestContext[0m
    [32mAnd[0m [32mthe logged args should contain "level": "2"[0m           [1;30m# logger_decorator_bdd_test.go:560 -> *LoggerDecoratorBDDTestContext[0m

  [1;37mScenario:[0m Filter decorator by key-value pairs                                [1;30m# features/logger_decorator.feature:92[0m
    [32mGiven[0m [32mI have a base logger[0m                                                 [1;30m# logger_decorator_bdd_test.go:529 -> *LoggerDecoratorBDDTestContext[0m
    [32mWhen[0m [32mI apply a filter decorator that blocks logs where "env" equals "test"[0m [1;30m# logger_decorator_bdd_test.go:542 -> *LoggerDecoratorBDDTestContext[0m
    [32mAnd[0m [32mI log an info message "production log" with args "env", "production"[0m   [1;30m# logger_decorator_bdd_test.go:548 -> *LoggerDecoratorBDDTestContext[0m
    [32mAnd[0m [32mI log an info message "test log" with args "env", "test"[0m               [1;30m# logger_decorator_bdd_test.go:548 -> *LoggerDecoratorBDDTestContext[0m
    [32mThen[0m [32mthe base logger should have received 1 message[0m                        [1;30m# logger_decorator_bdd_test.go:562 -> *LoggerDecoratorBDDTestContext[0m
    [32mAnd[0m [32mthe logged message should be "production log"[0m                          [1;30m# logger_decorator_bdd_test.go:563 -> *LoggerDecoratorBDDTestContext[0m

  [1;37mScenario:[0m Filter decorator by log level                                      [1;30m# features/logger_decorator.feature:100[0m
    [32mGiven[0m [32mI have a base logger[0m                                                 [1;30m# logger_decorator_bdd_test.go:529 -> *LoggerDecoratorBDDTestContext[0m
    [32mWhen[0m [32mI apply a filter decorator that allows only "info" and "error" levels[0m [1;30m# logger_decorator_bdd_test.go:543 -> *LoggerDecoratorBDDTestContext[0m
    [32mAnd[0m [32mI log an info message "info message"[0m                                   [1;30m# logger_decorator_bdd_test.go:547 -> *LoggerDecoratorBDDTestContext[0m
    [32mAnd[0m [32mI log a debug message "debug message"[0m                                  [1;30m# logger_decorator_bdd_test.go:549 -> *LoggerDecoratorBDDTestContext[0m
    [32mAnd[0m [32mI log an error message "error message"[0m                                 [1;30m# logger_decorator_bdd_test.go:551 -> *LoggerDecoratorBDDTestContext[0m
    [32mAnd[0m [32mI log a warn message "warn message"[0m                                    [1;30m# logger_decorator_bdd_test.go:550 -> *LoggerDecoratorBDDTestContext[0m
    [32mThen[0m [32mthe base logger should have received 2 messages[0m                       [1;30m# logger_decorator_bdd_test.go:562 -> *LoggerDecoratorBDDTestContext[0m
    [32mAnd[0m [32mthe messages should have levels "info", "error"[0m                        [1;30m# logger_decorator_bdd_test.go:568 -> *LoggerDecoratorBDDTestContext[0m

11 scenarios ([32m11 passed[0m)
100 steps ([32m100 passed[0m)
10.041214ms
time=2025-09-07T08:30:39.812Z level=INFO msg="[TEST] Testing decorator with real slog" test=integration
2025/09/07 08:30:40 INFO Loading tenant configurations from files directory=/this/directory/should/not/exist pattern=^tenant\d+\.json$
2025/09/07 08:30:40 ERROR Tenant config directory does not exist directory=/this/directory/should/not/exist
2025/09/07 08:30:40 ERROR Failed to load tenant configurations error="tenant config directory does not exist: stat /this/directory/should/not/exist: no such file or directory"
goos: linux
goarch: amd64
pkg: github.com/GoCodeAlone/modular
cpu: AMD EPYC 7763 64-Core Processor                
BenchmarkRegisterService/N=10-4         	  277192	      4257 ns/op	    3465 B/op	      58 allocs/op
BenchmarkRegisterService/N=100-4        	   30810	     40452 ns/op	   30073 B/op	     433 allocs/op
BenchmarkRegisterService/N=1000-4       	    2186	    485643 ns/op	  372505 B/op	    4802 allocs/op
BenchmarkRegisterService/N=10000-4      	     202	   5923924 ns/op	 3620664 B/op	   49935 allocs/op
BenchmarkGetService/N=10-4              	100000000	        11.56 ns/op	       0 B/op	       0 allocs/op
BenchmarkGetService/N=100-4             	96889953	        12.20 ns/op	       0 B/op	       0 allocs/op
BenchmarkGetService/N=1000-4            	79764386	        14.98 ns/op	       0 B/op	       0 allocs/op
BenchmarkGetService/N=10000-4           	59031624	        20.42 ns/op	       0 B/op	       0 allocs/op
BenchmarkGetService_Miss-4              	122746249	         9.805 ns/op	       0 B/op	       0 allocs/op
PASS
ok  	github.com/GoCodeAlone/modular	13.443s
